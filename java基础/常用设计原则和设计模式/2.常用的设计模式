基本分类：
    创建型模式：
        单例设计模式：主要分为饿汉式 和懒汉式，懒汉式存在多线程访问的问题
        
        工厂方法设计模式：普通工厂方法：
                                就是建立一个工厂类，对实现了同一接口的不同实现类进行实例的创建
                                缺点：如果传递的字符串出错，则不能正确地创建对象，并且可能出现空指针异常
                         多个工厂方法模式：
                         静态工厂方法模式：
                         
             工厂方法设计模式适合：
                    凡是出现了大量的产品需要创建且具有共同的接口时，可以通过工厂方法模式进行创建
             主要缺点：
                    类的创建依赖工厂类，也就是说，如果想要扩展程序生产新的产品，
                    就必须对工厂类的代码进行修改，这就违背了开闭原则
        抽象工厂模式：
       
    结构性模式：
        装饰器模式：就是给一个对象动态的则昂加一些新功能
                要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例
             实际意义：
                可以实现一个类功能的扩展
                可以动态的增加功能，而且还能动态撤销(继承不行)
                缺点：产生过多类似的对象，不易排错
                
        代理模式：代理模式就是找一个代理类替原对象进行一些操作，类似于生活中的中介
            实际意义：
                >>如果再使用的时候需要对原有的方法进行改进，可以采用一个代理类调用原有方法，
                   并且对产生的结果进行控制，这种方法就是代理模式
                >>使用代理模式，可以将功能划分的更为清晰，有利于后期维护
                
        装饰器模式和代理模式的比较：
                >>装饰器模式通常的做法是将原始对象作为一个参数传递给装饰者的构造器，
                    而代理模式通常在一个代理类中创建一个被代理类的对象
                >>装饰器模式关注于一个对象上动态的添加方法
                    代理模式关注于控制对 对象的访问
        
    行为型模式：
        模板方法模式：主要指抽象类中封装了一个固定流程，流程中的具体步骤可以由不同子类进行不同的实现，
                        通过抽象类让固定的流程产生不同的结果      
             实际意义：
                >>将多个子类共有并且逻辑相同的内容提取出来实现代码复用
                >>不同的子类实现不同的效果形成多态，有助于后期维护
        
